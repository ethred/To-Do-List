"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_debug_1 = require("@hint/utils-debug");
const utils_types_1 = require("@hint/utils-types");
const utils_css_1 = require("@hint/utils-css");
const cssPropertiesObject = require('./assets/CSSReflow.json') || {};
const i18n_import_1 = require("./i18n.import");
const layout_1 = require("./meta/layout");
const debug = (0, utils_debug_1.debug)(__filename);
class DetectCssLayoutHint {
    constructor(context) {
        const validateRule = (rule) => {
            debug(`Validating detect-css-reflows`);
            const results = new Set();
            rule.each((decl) => {
                if (!('prop' in decl) || (decl.toString() === 'not valid')) {
                    return;
                }
                const name = decl.prop;
                const baseName = (0, utils_css_1.getUnprefixed)(name);
                const propertyName = cssPropertiesObject[baseName];
                if (propertyName && propertyName.layout) {
                    results.add(decl);
                }
            });
            return results;
        };
        const validateAtRule = (rule) => {
            let results = new Set();
            if (rule.name === 'keyframes') {
                rule.each((decl) => {
                    switch (decl.type) {
                        case 'rule': {
                            results = new Set([...results, ...validateRule(decl)]);
                            break;
                        }
                        default: {
                            break;
                        }
                    }
                });
            }
            return results;
        };
        const formatMessage = (declaration) => {
            const propertyName = declaration.prop;
            const affectedTriggers = cssPropertiesObject[propertyName];
            const cssDeclarationTrigger = Object.getOwnPropertyNames(affectedTriggers).map((item) => {
                if (item === 'layout' && affectedTriggers[item]) {
                    return `${item.charAt(0).toLocaleUpperCase()}${item.slice(1).toLowerCase()}`;
                }
                return null;
            });
            const triggeredCSSChangesArray = cssDeclarationTrigger.filter((item) => {
                return item !== null;
            }).join(', ');
            return (0, i18n_import_1.getMessage)('issueMessage', context.language, [propertyName, triggeredCSSChangesArray]);
        };
        context.on('parse::end::css', ({ ast, element, resource }) => {
            debug('Validating detect-css-reflows');
            for (const node of ast.nodes) {
                switch (node.type) {
                    case 'atrule': {
                        const results = validateAtRule(node);
                        for (const declaration of results) {
                            const location = (0, utils_css_1.getCSSLocationFromNode)(declaration, { isValue: false });
                            const severity = utils_types_1.Severity.hint;
                            const message = formatMessage(declaration);
                            const codeSnippet = (0, utils_css_1.getFullCSSCodeSnippet)(declaration);
                            context.report(resource, message, {
                                codeLanguage: 'css',
                                codeSnippet,
                                element,
                                location,
                                severity
                            });
                        }
                        break;
                    }
                    default:
                        break;
                }
            }
        });
    }
}
exports.default = DetectCssLayoutHint;
DetectCssLayoutHint.meta = layout_1.default;
